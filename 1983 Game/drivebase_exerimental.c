#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S3,     touch1,         sensorTouch)
#pragma config(Sensor, S4,     touch2,         sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     motorA,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorB,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorC,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorD,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     armA,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     armB,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     collector,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "drivebase.c"


void drive_distance(float distance_in_meters)
{
	/*
	* Currently, this is just your basic tankdrive() call follwed by a call to wait1Msec()
	* The thing is, we really want to think about driving a specific distance, not for a specific time.
	*
	* Without encodrs, you need to time how long it takes for the robot to travel one meter
	* this becomes your seconds_per_meter scale factor.
	* if we don’t have encoders to measure actual distance traveled by the motors, we can
	* just use distance_in_meters * scale_factor as a “wait time”
	*/
	float seconds_per_meter = 0.3; // total wild guess, need to fix this number

	// tankdrive(25, 25); // slow throttle settings are more acccurate
	mecanum_drive(0, 25, 0)

	// convert meters to seconds, then multiple by 1,000 for miliseconds.
	wait1Msec((distance_in_meters * seconds_per_meter) * 1000);

	/*
	* in the future, when we know how to work with encoders, we can
	* drop the whole wait1Msec thing and count enoder ticks instead
	* The cool thing is, the innputs to drive_distance() won't have to change!
	*/

	/*
	* Look at the code in
	*  C:\Program Files\Robomatter Inc\
	*        ROBOTC Development Environment 4.X\
	*          Sample Programs\NXT\NXT Advanced Motor Commands\
	*             NXT nMotorTargetEncoders Example.c
	*
	* The guts of its task_main() could be put in here.  There's a
	* nMotorEncoder[] you use to clear/zero-out the encoder,
	* then you use nMotorEncoderTarget to say how many degrees(I think)
	* to rotate.  So to drive the robot a meter, or rotate it 90 degrees,
	* that's going to be a lot of motor rotations!
	*/
}


void turn_degree (float degrees_to_turn)
{
	/*
	* similar idea to drive_distance(), it's a call to tankdrive() follwed by a call to wait1Msec();
	* This time, you need to time how long it takes the robot to turn 90 degrees.
	*/
	float seconds_for_90_degrees = 0.8 // total wild guess, need to change this.
	short throttle_setting = 25;

	/*
	* The other thing you need to deal with is left vs. right turns.  Need to check if
	* degrees_to_turn is postive or negatie, then figure out whether left side or right side
	* of tankdrive throttle needs to be positive.
	*/
	/*
	if (degrees_to_turn < 0.0)
	{
		tankdrive (throttle_setting, -throttle_setting); // low throttle settings are more accurate.
	}
	else
	{
		tankdrive (-throttle_setting, throttle_setting);
	}
       */

	if (degrees_to_turn < 0.0)
	{
		mecanum_drive (0, 0, throttle_setting); // low throttle settings are more accurate.
	}
	else
	{
		mecanum_drive (0, 0, -throttle_setting); // low throttle settings are more accurate.
	}


	/*
	* convert degrees_to_turn into seconds, by multipling by second_for_90_degrees,
	* then divide by 90. Next, multiply by 1,000 to get miliseconds
	*/
	wait1Msec(degrees_to_turn * seconds_for_90_degrees / 90.0 * 1000.0;

	/*
	* in the future, when we know how to work with encoders, we can
	* drop the whole wait1Msec thing and count enoder ticks isntead
	* The cool thing is, the innputs to turn_degree() won't have to change!
	*/

}
