#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S3,     touch1,         sensorTouch)
#pragma config(Sensor, S4,     touch2,         sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     motorA,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorB,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorC,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorD,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     armA,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     armB,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     collector,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "drivebase.c"

/*
* As of 11/15/14, dirive_distance calls mecanum_drive to move forward or
* backward, based on whether user provides a postive or negative distance.
* the main call is mecanum_drive(0, 25, 0)
*
* If you want the robot to move sideways in autonmous, you could make a
* new drive_sideways() function that would look just like drive_distance()
* except it would call mecanum_drive_(25, 0, 0)
*/
void drive_distance(float distance_in_meters)
{
	/* CALLIBRATION ISNTRUCTIONS
	* Setting second_per_meter to 1.0 will make drive_distance() act like it's driving for a number
	* seconds instead of meters.  In other words, if you set second_per_meter to 1.0, then call
	* drive_distance(1.0), the robot will travel for one seecond.  You can measure how far it goes in
	* meters (might be less than a meter .. 0.56 or something like that. Take the inverse of that
	* measurement (e.g. 1/0.56), use that value for seconds_per_meter, and you should be in pretty good
	* shape.
	*/

	float seconds_per_meter = 1.0; // total wild guess, need to fix this number

	// tankdrive(25, 25); // slow throttle settings are more acccurate


	// The arguments to mecanum_drive() are leftRight, frontBack, and Pivot
	// calling mecanum_drive(0, 25, 0) will make the robot go forward at
	// 25% throttle setting.  You can experiment with faster or slower settings.

	/* TO-DO ... ADD SOME CODE
	need a varialble called speed in stead of number 25.
	if distance_in_meters is negative, then speed needs to be negative too.
	*/
	mecanum_drive(0, 25, 0)

	// convert meters to seconds, then multiple by 1,000 for miliseconds.
	wait1Msec((distance_in_meters * seconds_per_meter) * 1000);

	/*
	* in the future, when we know how to work with encoders, we can
	* drop the whole wait1Msec thing and count enoder ticks instead
	* The cool thing is, the innputs to drive_distance() won't have to change!
	*/

	/*
	* Look at the code in
	*  C:\Program Files\Robomatter Inc\
	*        ROBOTC Development Environment 4.X\
	*          Sample Programs\NXT\NXT Advanced Motor Commands\
	*             NXT nMotorTargetEncoders Example.c
	*
	* The guts of its task_main() could be put in here.  There's a
	* nMotorEncoder[] you use to clear/zero-out the encoder,
	* then you use nMotorEncoderTarget to say how many degrees(I think)
	* to rotate.  So to drive the robot a meter, or rotate it 90 degrees,
	* that's going to be a lot of motor rotations!
	*/
}


void turn_degree (float degrees_to_turn)
{
	/*
	* similar idea to drive_distance(), it's a call to mecanum_drive() follwed by a call to wait1Msec();
	*/

	/* CALLIBRATION INSTRUCTIONS
	* Setting seconds_for_90_degrees to 90 will make turn_degree() act like it's turning for a number
	* of seconds instead of degrees.  Best way to calibrate it is to call degrees_to_turn(10) or something,
	* like that, and time how long it takes the robot to turn 90 degrees.  If it's too fast, slow down its
	* throttle setting.
	*/
	float seconds_for_90_degrees = 90.0 // total wild guess, need to change this.
	short throttle_setting = 25;

	/*
	* The other thing you need to deal with is left vs. right turns.  Need to check if
	* degrees_to_turn is postive or negatie, then figure out whether left side or right side
	* of tankdrive throttle needs to be positive.
	*/
	/*
	if (degrees_to_turn < 0.0)
	{
	tankdrive (throttle_setting, -throttle_setting); // low throttle settings are more accurate.
	}
	else
	{
	tankdrive (-throttle_setting, throttle_setting);
	}
	*/

	if (degrees_to_turn < 0.0)
	{
		mecanum_drive (0, 0, throttle_setting); // low throttle settings are more accurate.
	}
	else
	{
		mecanum_drive (0, 0, -throttle_setting); // low throttle settings are more accurate.
	}


	/*
	* convert degrees_to_turn into seconds, by multipling by second_for_90_degrees,
	* then divide by 90. Next, multiply by 1,000 to get miliseconds
	*/
	wait1Msec(degrees_to_turn * seconds_for_90_degrees / 90.0 * 1000.0;

	/*
	* in the future, when we know how to work with encoders, we can
	* drop the whole wait1Msec thing and count enoder ticks isntead
	* The cool thing is, the innputs to turn_degree() won't have to change!
	*/

}
