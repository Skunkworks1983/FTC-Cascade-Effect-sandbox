#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S3,     touch1,         sensorTouch)
#pragma config(Sensor, S4,     touch2,         sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     motorA,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorB,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorC,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorD,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     armA,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     armB,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     collector,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorK,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)

/* Original Vex Pragmas
#pragma config(Motor,  port2,           frontRight,    tmotorNormal, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorNormal, openLoop)
#pragma config(Motor,  port4,           frontLeft,     tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port5,           backLeft,      tmotorNormal, openLoop, reversed)
*/

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Thise file orignally came from
C:\Program Files\Robomatter Inc\ROBOTC Development Environment 4.X\
Sample Programs\VEX2\Remote Control\Mecanum Drive with Deadzone Thresholds.c
*/


/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Mecanum Drive with Deadzone Thresholds
- This program allows you to remotely control a robot with mecanum wheels.
- The left joystick Y-axis controls the robot's forward and backward movement.
- The left joystick X-axis controls the robot's left and right movement.
- The right joystick X-axis controls the robot's rotation.
- This program incorportes a threshold/deadzone that allows very low Joystick values to be ignored.
This allows the robot to ignore values from the Joysticks when they fail to center at 0,
and provides a margin of error for the driver when they only want the robot to move in one axis.

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 2        frontRight          VEX Motor             Front Right motor
Motor Port 3        backRight           VEX Motor             Back Right motor
Motor Port 4        frontLeft           VEX Motor             Front Left motor
Motor Port 5        backLeft            VEX Motor             Back Left motor
----------------------------------------------------------------------------------------------------*/

#include "JoystickDriver.c"

task main()
{
	//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;

	//Loop Forever
	while(1 == 1)
	{
		/** Original Vex Code
		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch3]) > threshold)
		Y1 = vexRT[Ch3];
		else
		Y1 = 0;
		//Create "deadzone" for X1/Ch4
		if(abs(vexRT[Ch4]) > threshold)
		X1 = vexRT[Ch4];
		else
		X1 = 0;
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch1]) > threshold)
		X2 = vexRT[Ch1];
		else
		X2 = 0;

		//Remote Control Commands
		motor[frontRight] = Y1 - X2 - X1;
		motor[backRight] =  Y1 - X2 + X1;
		motor[frontLeft] = Y1 + X2 + X1;
		motor[backLeft] =  Y1 + X2 - X1;
		*/

		/*
		The wierd VexRT varaibles are the way Vex talks to its joystick.

		Vex runs off of the kind of radio transmitter you'd use to fly an
		RC Plane.  One big box, with two joysticks, operated by your thumbs.
		Below is a mapping from these vexRT vars to an FTC game controlller

		Vex variable          Meaning             FTC controller
		------------    ----------------------    ----------------
		vexRT[Ch3]   == left  joystick, y-axis == joystick.joy1_y1
		vexRT[Ch4]   == left  joystick, x-axis == joystick.joy1_x1
		vexRT[Ch1]   == right joystick, x-axis == joystick.joy1_x2
		*/

		//Create "deadzone" for Y1/Ch3
		if(abs(joystick.joy1_y1) > threshold)
			Y1 = joystick.joy1_y1;
		else
			Y1 = 0;
		//Create "deadzone" for X1/Ch4
		if(abs(joystick.joy1_x1) > threshold)
			X1 = joystick.joy1_x1;
		else
			X1 = 0;
		//Create "deadzone" for X2/Ch1
		if(abs(joystick.joy1_x2) > threshold)
			X2 = joystick.joy1_x2;
		else
			X2 = 0;

		// Modified code, for FTC
		// Not sure if the front motors are A and B, or C and D.
		motor[motorB] = Y1 - X2 - X1;
		motor[motorD] = Y1 - X2 + X1;
		motor[motorA] = Y1 + X2 + X1;
		motor[motorC] = Y1 + X2 - X1;

		// if the code above makes the robot go backwards, comment it out, and
		// uncomment the code belo by deleting the /* and the */

		/*
		motor[motorB] = Y1 - X2 - X1;
		motor[motorD] = Y1 - X2 + X1;
		motor[motorC] = Y1 + X2 + X1;
		motor[motorA] = Y1 + X2 - X1;

		*/

	}
}
